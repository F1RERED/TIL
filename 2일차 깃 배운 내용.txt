버전 기록하기 위한 명령어
git add <file/directory>
git commit -m 'message'
----
push는 원격저장소에 보내는 명령어. 버전 기록을 위한 명령어는 아니다.

Untracked : 한번도 커밋 된적 없는 파일 1통

Changes not staged for commit
커밋을 실행했는데 스테이징 에리어에 아무것도 없음을 의미

nothing to commit, working tree clean
이전버전에 비교해서 변경사항이 아예 없다. add한 작업물도 없다. 1통2통X

깃 = 버전관리시스템

깃허브 = 깃의 원격 저장소



Q.깃허브에 영상이나 ppt 업로드 가능?
A. 모든 종류 파일 관리 가능. 
하지만 순수 텍스트 파일은 이전 버전에 비해 달라진 점 및 추가점을 볼 수 있는데
이미지나 동영상, 피피티 등 파일등은 그런 걸 볼 수 없음.
또한, 깃허브에는 용량제한이 있음. 그래서 용량큰 종류의 데이터파일은 드라이브 링크로 공유 하기도 함.


Q. 깃허브 출석 네모칸 칠하는 방법
A. 오로지 커밋으로만 가능.


Q. 내용이 없는 텍스트파일 인식 안함?
A. Yes


git remote rm origin
이미 로컬영역에 origin이라는 변수에 등록된 주소 제거

항상 커밋하기전엔 git status로 꼬옥 확인해야함


git commit을 쓰면 터미널 창에 입력창이 뜨는 데
esc나갈 수 있음
git config --global core.editor "code --wait"
이걸 쓰면 다음에 
git commit만 쓰면 코드시트 페이지가 뜨면서 거기에 작성할 수 있게 되고
그것을 종료하면 자동으로 커밋이됨


Q. 이전에 작업하던 프로젝트에 새로운 폴더를 만들고 커밋 후 push하면 제대로 구동 될까?
A. 기존 로컬과 관련이 없던 히스토리를 병합하면 오류가 발생

Q. 원격 저장소 이름을 바꿧다면?
주소가 바뀐거니 로컬 원격저장소도 재설정해줘야함


공유하면 안되는 정보 은닉해야하는 프로젝트 진행 시
ex) 개인정보 담긴 것
중요정보가 담긴 특정 파일을 무시하고 싶다면
 .gitignore 라는 파일을 만들고
그 안에 무시하고 싶은 파일명을 적으면 된다.
ex) users.csv

*.csv	모든 csv 파일 무시해줘
*.png	모든 png파일 무시해줘

Q. .gitignore은 status에 뜨는데 그러면 .gitignore은 add해줘야하는건가요
A. Yes. .gitignore는 계속 커밋 해줘야함

실례) 운영체제 관련 파일. 프로젝트 진행 시 컴퓨터 때문에 필요한데 프로젝트에는 없어도 되는 파일
개발 언어: 파이썬, IDE: 텍스트에디터

https://www.toptal.com/developers/gitignore/
개발자들이 일반적으로 프로젝트 시 쓰는 .gitignore 파일을 제공해줌
OS체제, 컴퓨터언어, 실행프로그램(ex. VScode) 이런거 적어주면 같은 환경으로 쓸 .gitignore 파일 보여줌


깃허브에 올라온 내용을 받는 명령어는? pull
푸쉬의 반대니까

git log로 버전 확인


깃허브에서도 파일 수정이 가능함
이걸 하게 되면 로컬과 버전이(히스토리가) 달라져서 더이상 로컬에서 푸쉬가 안됨
해결법은?
1)pull 받아서 내용 수정후 push

pull 과정에서 같은 파일의 다른 부분이 있으니까 충돌되었다고 보여주면서
어디가 다른 지 짚어줌 깃이.
이 부분 수정하고 애드 커밋 하면 됨

2) 기존 리포지토리 삭제하고 새로 만들고 푸쉬

깃허브에서 히스토리 삭제는 불가능...분서갱유 같은 것



메인 브랜치는 실제 출시 버전 브랜치

브랜치 과정에서 다른 파일만 서로 있으면 무리없이 잘 합쳐지고
합쳐지는 과정에서 같은 파일 건드려서 충돌이 발생하면 아까 pull한것처럼 수정해주면 됨

브랜치와 메인 통합하는 것이 
merge
근데 merge는 pull에서도 발생
깃헙에서 수정하고 로컬과 합치는 것도 엄연한 브랜치에서 파생된걸 통합하는 것

pull은 2가지 명령의 조합
fetch: 브랜치를 가져오는 행위
merge: 통합 하는 행위

git branch <branchname>
브랜치 생성
git checkout <branchname>
터미널을 브랜치로 작업으로 변경

브랜치 작업 중에 다른 브랜치나 메인을 수정하고 커밋하고 푸쉬하면
작업 중인 브랜치는 푸쉬되지 않음. 독립된 작업이라 그럼
브랜치까지 푸쉬하려면 작업  완료후 브랜치를 따로 추쉬하던가 아니면 merge
merge branch <branchname>
메인에 브랜치 통합

브랜치끼리 통합 - 공유하는 메인에서 통합하려는 브랜치 머지하면 됨


깃허브 풀(pull) 리퀘스트

브랜치를 따로 커밋 푸쉬하면 깃허브에서 브랜치가 새로 생김
여기서 pull request가 있는데
머지 요청하는 거임
이러면 같이 작업하는 팀장이 이걸 보고 깃허브 넷상에서 머지해주는 버튼을 누를 수 있음
이러면 로컬이 아닌 깃헙에서 머지하게 됨

깃헙에서 머지 중에 충돌 발생하면 깃헙에서 수정창이 뜸
간단한 거는 넷상에서 고치면 되는데 복잡한 거는 실행시켜봐야되서
머지 담당자(=팀장)이 로컬로 해보고 머지하는 게 맞음

깃허브의 소스는 권한을 제약할 수 있어서 외부인이 중요한걸 막 수정할 순 없음

git clone 'fork주소'
다른 사람의 작업물을 복제할 수 있음
히스토리까지 받아지기 때문에 다른 사람이 이어서 작업 가능
다만 여기서 수정 후 그냥 커밋 푸쉬를 하면 에러난다
왜냐하면 내 자료, 내 깃이 아니기 때문에

이걸 도와주는 것이 fork. 상대 깃을 내 깃허브주소로 가져온다.
일종의 공유같은 것.
이러면 이제 복사한 주소로 푸쉬가능
푸쉬 후 원제작자에게 머지해달라고 풀 리퀘스트 보낼 수 있음
머지 권한은 해당 소스 제작자에게 있음
클론 주소는 포크해서 가져온 내 주소로 해야됨

fork를 통해 풀 리퀘스트 하는 이유? = 내가 권한이 없어서
초대 받지 않아도 기여할 수 있음
다수 개발자들 참여 프로젝트는 이렇게도 할 수 있음


@@@
git remote -v
로컬에 등록된 원격 저장소 주소 보는 명령어
ex)
$ git remote -v
origin  https://github.com/F1RERED/git-0608 (fetch)
origin  https://github.com/F1RERED/git-0608 (push)
오리진이란 변수와 거기에 등록된 주소
fetch는 받아오는 주소
push는 보내는 주소
나중엔 이거 따로 설정해서 사용하기도 함


풀 리퀘스트는 확인해보면
$git ~~~
명령어 입력한 것들도 볼 수 있음


https://octoverse.github.com/
오픈소스 및 정보

https://git-scm.com/book/ko/v2
깃 특강 배운 내용이 담긴 책
무료. 웹문서. pdf 지원(pdf는받음)

https://backlog.com/git-tutorial/kr/intro/intro1_1.html
깃 입문 웹문서